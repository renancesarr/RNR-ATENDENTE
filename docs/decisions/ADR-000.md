# ADR-000: Arquitetura Geral do MVP

- **Status**: Accepted
- **Context Timestamp**: 2025-10-12

## Contexto
Precisamos estabelecer a arquitetura base do MVP de atendimento via WhatsApp, garantindo latência baixa, rastreabilidade das conversas e integração com IA generativa. O escopo mínimo inclui:
- Evolution API v2 para gerenciar sessões WhatsApp (envio/recepção de mensagens, QR code, webhooks).
- Postgres com extensão `pgvector` para persistência transacional, histórico e embeddings.
- Redis como cache de baixa latência para sessões e throttling.
- RabbitMQ como barramento de eventos (KPIs, RAG, integrações externas).
- OpenAI para geração de respostas com RAG.

O time precisa de um desenho único que oriente backlog, infraestrutura e decisões subsequentes (observabilidade, segurança, custos).

## Fatores de decisão
- Garantir time-to-first-response (TTFR) baixo em um ambiente controlado pela equipe.
- Custos previsíveis e aderência ao orçamento de MVP.
- Manutenibilidade pela equipe atual (stack conhecida, ferramental containerizado).

## Opções consideradas
1. **Stack self-hosted com Docker Compose** (Evolution API + Postgres + Redis + RabbitMQ + apps auxiliares)
   - Prós: controle total do ambiente; baixo custo inicial; fácil replicação local.
   - Contras: manutenção de infraestrutura é responsabilidade do time; demanda monitoramento de recursos.
   - Impacto: custo operacional baixo, latência sob controle; requer rotinas de backup/observabilidade próprias.
2. **Serviços totalmente gerenciados em cloud (ex.: Twilio, Cloud SQL, AWS MQ)**
   - Prós: SLA elevado, menos responsabilidades de infraestrutura.
   - Contras: custo significativamente maior para o MVP; dependência de múltiplos provedores; maior esforço de integração.
   - Impacto: latência dependente de provedores; custo recorrente alto; reduz esforço de manutenção.
3. **Arquitetura serverless/event-driven com API Gateway + Functions**
   - Prós: escalabilidade automática; custo sob demanda.
   - Contras: maturidade da equipe menor; integração complexa com Evolution API self-hosted; cold start penaliza TTFR.
   - Impacto: latência potencialmente maior; custo imprevisível em picos; monitoração distribuída.

## Decisão
Adotamos a opção 1: stack autocontida via Docker Compose em host único. Essa abordagem maximiza controle sobre componentes críticos (Evolution API e banco), facilita desenvolvimento local e permite ajustes finos de latência e observabilidade compatíveis com o MVP. Mantemos a flexibilidade para evoluir para serviços gerenciados em fases posteriores.

## Consequências
- Positivas: ambiente reproduzível; integrações internas simplificadas; menor dependência externa; base consistente para testes automatizados.
- Riscos: necessidade de planejar monitoramento de recursos, backup e atualizações de segurança; exige playbooks operacionais claros.
- Mitigações: seguir ADRs específicos de observabilidade, backup e custos; automatizar scripts de saúde e rotinas de atualização.

## Follow-up
- [ ] Implementar runbooks de provisioning e observabilidade (docs/solution-architect).
- [ ] Avaliar custo total de operação trimestralmente (ver ADR de custos).
